# 克隆仓库
- git clone xxx
# git相关操作
- git checkout -b note
- git add .
- git commit -m 'note'
- git push origin note
# 整体应用BEM风格
- block：块
- element：元素
- modifier：修饰符

## 解释

- 块：独立的实体，它本身是有意义的，就像应用的一块“积木”，一个块既可以是简单的也可以是复合的（包含其他块）。

- 元素：块的一部分，没有独立的含义，并且在语义上与其块相关联

- 修饰符：块或元素上的标志。用它们来改变外观或行为。

## 写法

- 块：.block
- 元素：.block__element
- 修饰符：.block--modifier

# 创建Vue项目
- vue create My-element
- Bebal
- CSS Pro-processors  SASS
- Linter/Formatter  ESLint-Airbnb config  Lint on save
- Unit Testing  Jest  
- In dedicated config files

git
- code.

## gitignore
git上传时忽略的文件以及文件夹

# merge 到主分支
- git checkout master //merge时需要切换到主分支
- git merge xxx（需要被merge到主分支的分支）
- git push origin master //覆盖到master分支

# layout布局组件
- git checkout -b layout //新建分支
- components/element/【新建Row.vue以及Col.vue】
- components/element作为储存元素组件的文件夹
- 新建vue.config.js进行设置路径别名
```js
const path = require('path');
module.exports = {
    /*chainWebpack修改
    chainWebpack:(config)=>{
        config.resolve.alias.set('@element',path.resolve(__dirname,'src/components/element'))
    }
    */
    configureWebpack:{
        resolve:{
            alias:{
                '@element':'@/components/element'
                //进行路径别名配置
            }
        }
    }
}
```
- eslint自动修复
```npm run lint --fix```
## App.vue
1. 测试模板
```html
<template id="App">
<!-- 基础响应式布局 -->
<!-- 组件通过绑定span变量改变组件的width-->
<!-- 注意：在设置el-col的width时，为了避免上级元素拥有padding值造成误差，需要在el-col设置浮动，同时父组件el-row清除浮动-->

    <el-row>
      <el-col :span="24"><div class="grid-content bg-purple-dark"></div></el-col>
    </el-row>
    <el-row>
      <el-col :span="12"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="12"><div class="grid-content bg-purple-light"></div></el-col>
    </el-row>
    <el-row>
      <el-col :span="8"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="8"><div class="grid-content bg-purple-light"></div></el-col>
      <el-col :span="8"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
    <el-row>
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple-light"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple-light"></div></el-col>
    </el-row>
    <el-row>
      <el-col :span="4"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="4"><div class="grid-content bg-purple-light"></div></el-col>
      <el-col :span="4"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="4"><div class="grid-content bg-purple-light"></div></el-col>
      <el-col :span="4"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="4"><div class="grid-content bg-purple-light"></div></el-col>
    </el-row>
<!-- 分栏间隔 -->
<!-- 父组件通过绑定gutter变量并传递给子组件改变子组件的padding值-->
<!-- 注意：由于设置padding值会改变基本盒子的width，会造成布局混乱，所以需要设置el-col为border-box盒子-->
<!-- 注意：由于子组件设置了border-box盒子所以首位段的外padding有空隙，需要在父组件设置同样大小的负margin进行抵消-->
    <el-row :gutter="20">
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
<!-- 混合布局 -->
<!-- 混合布局就是基础响应式布局和分栏间隔混合使用的布局-->
    <el-row :gutter="20">
      <el-col :span="16"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="8"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
    <el-row :gutter="20">
      <el-col :span="8"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="8"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="4"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="4"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
    <el-row :gutter="20">
      <el-col :span="4"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="16"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="4"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
<!-- 分栏偏移-->
<!-- el-col组件通过绑定offset、push、pull变量分别改变组件的margin-left值、(relative)left值、(relative)right值进行偏移-->
<!-- 注意：在设置(relative)left值、(relative)right值时，left优先级高于right，会导致right值失效，需要添加计算属性classList进行判断-->
    <el-row :gutter="20">
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="6" :offset="6"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
    <el-row :gutter="20">
      <el-col :span="6" :offset="6"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="6" :offset="6"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
    <el-row :gutter="20">
      <el-col :span="12" :offset="6"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
<!--对齐方式-->
<!--将 type 属性赋值为 'flex'，可以启用 flex 布局，并可通过 justify 属性来指定 start, center, end, space-between, space-around 其中的值来定义子元素的排版方式。-->
    <el-row type="flex" class="row-bg">
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple-light"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
    <el-row type="flex" class="row-bg" justify="center">
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple-light"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
    <el-row type="flex" class="row-bg" justify="end">
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple-light"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
    <el-row type="flex" class="row-bg" justify="space-between">
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple-light"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
    <el-row type="flex" class="row-bg" justify="space-around">
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple-light"></div></el-col>
      <el-col :span="6"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
<!-- Bootstrap响应式布局 -->
<!-- xs<768,sm≥768,md≥992,lg≥1200,xl≥1920 -->
    <el-row :gutter="10">
      <el-col :xs="8" :sm="6" :md="4" :lg="3" :xl="1"><div class="grid-content bg-purple"></div></el-col>
      <el-col :xs="4" :sm="6" :md="8" :lg="9" :xl="11"><div class="grid-content bg-purple-light"></div></el-col>
      <el-col :xs="4" :sm="6" :md="8" :lg="9" :xl="11"><div class="grid-content bg-purple"></div></el-col>
      <el-col :xs="8" :sm="6" :md="4" :lg="3" :xl="1"><div class="grid-content bg-purple-light"></div></el-col>
    </el-row>
<!-- 基于断点的隐藏类 -->
<!-- Element 额外提供了一系列类名，用于在某些条件下隐藏元素。这些类名可以添加在任何 DOM 元素或自定义组件上 -->
<!-- 直接书写style即可 -->
    <el-row :gutter="10">
      <el-col class="hidden-xs-only" :xs="8" :sm="6" :md="4" :lg="3" :xl="1"><div class="grid-content bg-purple"></div></el-col>
    </el-row>
</template>
```
2. 编写相关功能
```vue
<script>
// 导入row、col组件
import elRow from '@element/Row.js';
import elCol from '@element/Col.js';
export default {
    el:'#App',
    components:{
        // 使用el-row、el-col组件
        ElRow,
        ElCol
    }
}
</script>
```
3. 添加相关样式
```vue
<style lang=scss>
  .el-row {
    margin-bottom: 20px;
    &:last-child {
      margin-bottom: 0;
    }
  }
  .el-col {
    border-radius: 4px;
  }
  .bg-purple-dark {
    background: #99a9bf;
  }
  .bg-purple {
    background: #d3dce6;
  }
  .bg-purple-light {
    background: #e5e9f2;
  }
  .grid-content {
    border-radius: 4px;
    min-height: 36px;
  }
  .row-bg {
    padding: 10px 0;
    background-color: #f9fafc;
  }
  .hidden {
      &-xs-only {
          @media only screen and (max-width:768px-1){
              display:none;
          }
      }
      &-sm-only {
          @media only screen and (min-width:768px) and (max-width:992px-1){
              display:none;
          }
      }
      &-md-only {
          @media only screen and (min-width:992px) and (max-width:1200px-1){
              display:none;
          }
      }
      &-lg-only {
          @media only screen and (min-width:1200px) and (max-width:1920px-1){
              display:none;
          }
      }
      &-xl-only {
          @media only screen and (min-width:1920px){
              display:none;
          }
      }
      &-sm-and-down {
          @media only screen and (max-width:992px-1){
              display:none;
          }
      }
      &-sm-and-up {
          @media only screen and (min-width:768px){
              display:none;
          }
      }
      &-md-and-down {
          @media only screen and (max-width:1200px-1){
              display:none;
          }
      }
      &-md-and-up {
          @media only screen and (min-width:992px){
              display:none;
          }
      }
      &-lg-and-down {
          @media only screen and (max-width:1920px-1){
              display:none;
          }
      }
      &-lg-and-up {
          @media only screen and (min-width:1200px){
              display:none;
          }
      }
  }
</style>
```
## row组件
1. 编写template模板
基本模板的编写
```vue
<template>
<!-- 绑定class-->
<!-- v-bind:class对象格式使用--->
    <div 
        :class="[
            'el-row',
            {'el-row--flex':this.type === 'flex'},
            this.justify !== 'start' && `is-justify-${justify}`,
            this.align !== 'top' && `is-align-${align}`
        ]"
        :style="style"
    >
        <slot></slot>
    </div>
</template>
```
2. 进行功能的编写
```vue
<script>
export default {
    name:'ElRow',// 子组件可以通过$parent.$option.name获取
    props:{
        // 进行gutter变量的注册和校验
        // 需要将gutter传递给子组件el-col进行相关设置
        gutter:{
            type:Number,
            default:0
        },
        // 进行type变量的注册和校验
        type:String,
        // 进行justify变量的注册和校验，以及函数校验validator
        justify:{
            type:String,
            default:'start',
            validator:val=>['start','end','center','space-between','space-around'].includes(val)
        },
        // 进行align变量的注册和校验
        align:{
            type:String,
            default:'top',
            validator:val=>['top','middle','bottom'].includes(val)
        }
    },
    computed:{
        style(){
            const style = {};
            if(this.gutter){
                style.marginRight = -this.gutter / 2 + 'px';
                style.marginLeft = style.marginRight;
            }
            return style;
        }
    }
}
</script>
```
3. 设置style
```vue
<style lang="scss" scoped>
/* 由于el-col进行了浮动设置所以父元素需要清除浮动 */
.el-row {
    &::after,
    &::before{
        display:block;
        content:''
    }
    &::after{
        clear:both;
    }
    &--flex{
        //设置flex布局
        display:flex;
        //取消清除浮动的操作
        &::after,
        &::before{
            display:none;
        }
        &.is-justify-end{
            justify-content:flex-end;
        }
        &.is-justify-center{
            justify-content:center;
        }
        &.is-justify-space-between{
            justify-content:space-between;
        }
        &.is-justify-space-around{
            justify-content:space-around;
        }
        &.is-align-middle{
            align-items:center;
        }
        &.is-align-bottom{
            align-items:flex-end;
        }
    }
}
</style>
```
## col组件
1. 编写template模板
```vue
<template>
    <div 
        class="el-col"
        :class="classList"
        :style="style"
    >
        <slot></slot>
    </div>
</template>
```
2. 进行功能的编写
```vue
<script>
export default {
    props:{
        // 注册并校验span变量
        span:{
            type:Number,
            default:24,
        },
        // 注册并校验offset变量
        offset:{
            type:Number,
            default:0,
        },
        // 注册并校验push、pull变量
        push:{
            type:Number,
            default:0
        },
        pull:{
            type:Number,
            default:0
        },
        xs:[Number,Object],
        sm:[Number,Object],
        md:[Number,Object],
        lg:[Number,Object],
        xl:[Number,Object],

    },
    computed:{
        // 子组件可以通过$parent
        gutter(){
            // 通过this.$parent获取父级元素对象
            let parent = this.$parent;
            // 需要进行判断父级元素是否是el-row才能获取gutter
            while(parent && parent.$options.name!== 'ElRow'){
                parent = parent.$parent;
            }
            // 判断父级el-row元素是否具有gutter值，有的话是多少
            return parent ? parent.gutter : 0 ;
        },
        style(){
            const style = {};
            if(this.gutter){
                style.paddingRight=this.gutter/2 + 'px';
                style.paddingLeft = style.paddingRight;
            }
            return style;
        },
        classList(){
            const classList = [];
            ['span','offset','push','pull'].forEach((prop)=>{
                if(this[prop]){
                    // 判断组件是否含有特定属性
                    classList.push(
                        // 区分span和其他属性不一致的属性名
                        prop==='span'?
                        `el-col-${this[prop]}`:
                        `el-col-${prop}-${this[prop]}`
                    )
                }
            });
            // 进行'xs','sm','md','lg','xl'分析数组或对象
            ['xs','sm','md','lg','xl'].forEach((size)=>{
                if(typeof this[size] === 'number'){
                    classList.push(
                        `el-col-${size}-${this[size]}`
                    );
                }else if(typeof this[size] === 'object'){
                    const props = this[size];//对应对象
                    //Object.keys获取对象的键名
                    Object.keys(props).forEach((prop)=>{
                        //循环props的键名判断是否为span
                        classList.push(
                            prop==='span'?
                            `el-col-${size}-${props[prop]}`:
                            `el-col-${size}-${prop}-${props[prop]}`
                        )
                    })
                }
            })
            return classList;
        }

    }
}
</script>
```
3. 设置style
```vue
<style lang="scss">
.el-col {
    float:left;//为了确保响应式布局的el-col适应画面需要浮动
    box-sizing:border-box;//确保设置padding后整体盒子宽度不变，需要设置box-sizing为border-box

}
/* 
@for 使用scss使用for循环
$i 声明变量
from 0 从0开始
through 24 到24为止
#{$i} 键名使用变量
$i 值名使用变量
 */
 @for $i from 0 through 24 {
     .el-col-#{$i}{
         width:$i/24*100%;
     }
     .el-col-offset-#{$i}{
         margin-left:$i/24*100%;
     }
     .el-col-push-#{$i}{
         position:relative;
         left:$i/24*100%;
     }
     .el-col-pull-#{$i}{
         position:relative;
         right:$i/24*100%;
     }
 }
 /* xs<768,sm≥768,md≥992,lg≥1200,xl≥1920 */
@media only screen and (max-width:768px-1){
     @for $i from 0 through 24 {
         .el-col-xs-0 {
             display:none;
         }
         .el-col-xs-#{$i}{
             width:$i/24*100%;
         }
         .el-col-xs-offset-#{$i}{
             margin-left:$i/24*100%;
         }
         .el-col-xs-push-#{$i}{
             position:relative;
             left:$i/24*100%;
         }
         .el-col-xs-pull-#{$i}{
             position:relative;
             right:$i/24*100%;
         }
     }
 }
@media only screen and (min-width:768px){
     @for $i from 0 through 24 {
         .el-col-sm-0 {
             display:none;
         }
         .el-col-sm-#{$i}{
             width:$i/24*100%;
         }
         .el-col-sm-offset-#{$i}{
             margin-left:$i/24*100%;
         }
         .el-col-sm-push-#{$i}{
             position:relative;
             left:$i/24*100%;
         }
         .el-col-sm-pull-#{$i}{
             position:relative;
             right:$i/24*100%;
         }
     }
 }
@media only screen and (min-width:992px){
     @for $i from 0 through 24 {
         .el-col-md-0 {
             display:none;
         }
         .el-col-md-#{$i}{
             width:$i/24*100%;
         }
         .el-col-md-offset-#{$i}{
             margin-left:$i/24*100%;
         }
         .el-col-md-push-#{$i}{
             position:relative;
             left:$i/24*100%;
         }
         .el-col-md-pull-#{$i}{
             position:relative;
             right:$i/24*100%;
         }
     }
 }
@media only screen and (min-width:992px){
     @for $i from 0 through 24 {
         .el-col-md-0 {
             display:none;
         }
         .el-col-md-#{$i}{
             width:$i/24*100%;
         }
         .el-col-md-offset-#{$i}{
             margin-left:$i/24*100%;
         }
         .el-col-md-push-#{$i}{
             position:relative;
             left:$i/24*100%;
         }
         .el-col-md-pull-#{$i}{
             position:relative;
             right:$i/24*100%;
         }
     }
 }
@media only screen and (min-width:1200px){
     @for $i from 0 through 24 {
         .el-col-lg-0 {
             display:none;
         }
         .el-col-lg-#{$i}{
             width:$i/24*100%;
         }
         .el-col-lg-offset-#{$i}{
             margin-left:$i/24*100%;
         }
         .el-col-lg-push-#{$i}{
             position:relative;
             left:$i/24*100%;
         }
         .el-col-lg-pull-#{$i}{
             position:relative;
             right:$i/24*100%;
         }
     }
 }
@media only screen and (min-width:1920px){
     @for $i from 0 through 24 {
         .el-col-xl-0 {
             display:none;
         }
         .el-col-xl-#{$i}{
             width:$i/24*100%;
         }
         .el-col-xl-offset-#{$i}{
             margin-left:$i/24*100%;
         }
         .el-col-xl-push-#{$i}{
             position:relative;
             left:$i/24*100%;
         }
         .el-col-xl-pull-#{$i}{
             position:relative;
             right:$i/24*100%;
         }
     }
 }
</style>
```

